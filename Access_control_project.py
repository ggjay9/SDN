from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER, set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib.packet import packet, ethernet, ether_types, arp, ipv4, tcp, udp
from ryu.topology import event, switches
from ryu.topology.api import get_all_switch, get_all_link, get_all_host
import networkx as nx

class regole:
    count=0
    
    def __init__(self, dpid1, dpid2, table_id1):
        self.dpid1=dpid1
        self.dpid2=dpid2
        self.table_id1 = table_id1
        self.table_id2 = None
    
lista_regole = []
N_max_flussi = 3

class Progetto3(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    def __init__(self, *args, **kwargs):
        super(Progetto3, self).__init__(*args, **kwargs)
        self.mac_to_port = {}
        
    
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        
        self.mac_to_port.setdefault(datapath.id, {})
        
        match=parser.OFPMatch()
        actions=[parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]
        inst=[parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,actions)]
        
        mod=parser.OFPFlowMod(datapath=datapath, priority=0, match=match, instructions=inst)
        
        datapath.send_msg(mod)
        
        
    def find_destination_switch(self,destination_mac):
        for host in get_all_host(self):
            if host.mac == destination_mac:
                return (host.port.dpid, host.port.port_no)
        return (None,None)
    
    def find_next_hop_to_destination(self,source_id,destination_id):
        net = nx.DiGraph()
        for link in get_all_link(self):
            if len(lista_regole)==0:
                net.add_edge(link.src.dpid, link.dst.dpid, port=link.src.port_no)
            else:
                booleano2=0
                j=0
                while j<len(lista_regole):
                    if (link.src.dpid==lista_regole[j].dpid1 and link.dst.dpid==lista_regole[j].dpid2) or (link.src.dpid==lista_regole[j].dpid2 and link.dst.dpid==lista_regole[j].dpid1):
                        if lista_regole[j].count < N_max_flussi:
                            net.add_edge(link.src.dpid, link.dst.dpid, port=link.src.port_no)
                        booleano2=1
                    j+=1
                if booleano2==0:
                    net.add_edge(link.src.dpid, link.dst.dpid, port=link.src.port_no)
        
        path = nx.shortest_path(
            net,
            source_id,
            destination_id
        )
        first_link = net[ path[0] ][ path[1] ]
        
        
        self.logger.info("path: %s\n", path)
        return first_link['port'], path[1]
        
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def _packet_in_handler(self, ev):
        msg = ev.msg
        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        dpid1 = datapath.id
        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocol(ethernet.ethernet)
        
        
        # se ARP esegui proxy arp
        if eth.ethertype == ether_types.ETH_TYPE_ARP:
            self.proxy_arp(msg)
            return
        # ignora pacchetti non IPv4 (es. ARP, LLDP)
        
        ip_pkt = pkt.get_protocol(ipv4.ipv4)
        if ip_pkt is not None:
            ip_src = ip_pkt.src
            ip_dst = ip_pkt.dst
        else:
            return
        
        proto = ip_pkt.proto
        
        tcp_pkt = pkt.get_protocol(tcp.tcp)
        udp_pkt = pkt.get_protocol(udp.udp)
        if tcp_pkt is not None:
            port_src = tcp_pkt.src_port
            port_dst = tcp_pkt.dst_port
        elif udp_pkt is not None:
            port_src = udp_pkt.src_port
            port_dst = udp_pkt.dst_port
        else:
            # self.logger.info("Non TCP/UDP")
            # self.logger.info("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n")
            return
        self.logger.info("\n PACKET_IN:\n  Generated by switch %s", dpid1)
        self.logger.info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n")
        
        # trova switch destinazione
        (dst_dpid, dst_port) = self.find_destination_switch(eth.dst)
        # host non trovato
        if dst_dpid is None:
            self.logger.info("DP: ", datapath.id, "Host not found: ", pkt_ip.dst)
            self.logger.info("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n")
            return
        if dst_dpid == dpid1:
            # da usare se l'host e' direttamente collegato
            output_port = dst_port
            self.logger.info("Host directly linked to the switch (link without counter)")
        else:
            # host non direttamente collegato
            output_port, dpid2 = self.find_next_hop_to_destination(dpid1,dst_dpid)
            
            if len(lista_regole)==0:
                lista_regole.append(regole(dpid1, dpid2, output_port))
                lista_regole[-1].cont+=1
                self.logger.info("First rule of the link!")
                self.logger.info("Current number of flows on the link [sw %s <-> sw %s]: count = %d", dpid1, dpid2, lista_regole[-1].cont)
            else:
                i=0
                booleano=0
                while i<len(lista_regole):
                    if (dpid1==lista_regole[i].dpid1 and dpid2==lista_regole[i].dpid2) or (dpid1==lista_regole[i].dpid2 and dpid2==lista_regole[i].dpid1):
                        if dpid1==lista_regole[i].dpid2 and dpid2==lista_regole[i].dpid1:
                            lista_regole[i].table_id2 = output_port
                        lista_regole[i].cont+=1
                        booleano=1
                        self.logger.info("Counter increased")
                        self.logger.info("Current number of flows on the link [sw %s <-> sw %s]: count = %d", dpid1, dpid2, lista_regole[i].cont)
                    i+=1
                if booleano==0:
                    lista_regole.append(regole(dpid1, dpid2, output_port))
                    lista_regole[-1].cont+=1
                    self.logger.info("First rule of the link!")
                    self.logger.info("Current number of flows on the link [sw %s <-> sw %s]: count = %d", dpid1, dpid2, lista_regole[-1].cont)

        # aggiungi la regola
        
        if tcp_pkt is not None:
            match = parser.OFPMatch(
                                    eth_type = eth.ethertype, #2048
                                    ip_proto = proto, #6
                                    ipv4_src = ip_src,
                                    ipv4_dst = ip_dst,
                                    tcp_src = port_src,
                                    tcp_dst = port_dst
                                    )
        else:
            match = parser.OFPMatch(
                                    eth_type = eth.ethertype, #2048
                                    ip_proto = proto, #17
                                    ipv4_src = ip_src,
                                    ipv4_dst = ip_dst,                                    
                                    udp_src = port_src,
                                    udp_dst = port_dst
                                    )
        
        actions=[ parser.OFPActionOutput(output_port) ]
        
        inst=[parser.OFPInstructionGotoTable(output_port)]
        mod=parser.OFPFlowMod(datapath = datapath, table_id = 0, priority = 10, match = match, idle_timeout=5, instructions=inst)
        datapath.send_msg(mod)
        
        inst=[parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,actions)]
        #                                                                    TIMEOUT della REGOLA (5 sec) idle_timeout=5, flags=ofproto.OFPFF_SEND_FLOW_REM, 
        mod=parser.OFPFlowMod(datapath = datapath, table_id = output_port, priority = 10, match = match, idle_timeout=5, flags=ofproto.OFPFF_SEND_FLOW_REM, instructions = inst)
        datapath.send_msg(mod)
        
        
        self.logger.info("Rule installed in the Flow Table %s", output_port)
        self.logger.info("Rule match: %s\n", (proto, ip_src, ip_dst, port_src, port_dst)) 
        self.logger.info("Number link with active flows: %d", len(lista_regole))
        i=0
        while i<len(lista_regole):
            self.logger.info("Active links: %s --> %s", lista_regole[i].dpid1, lista_regole[i].dpid2)
            i+=1
        self.logger.info("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n")
        
        return
        
    def proxy_arp(self, msg):
        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']
        pkt_in = packet.Packet(msg.data)
        eth_in = pkt_in.get_protocol(ethernet.ethernet)
        arp_in = pkt_in.get_protocol(arp.arp)
        # gestiamo solo i pacchetti ARP REQUEST
        if arp_in.opcode != arp.ARP_REQUEST:
            return
        
        # self.logger.info("______________________\n")
        # self.logger.info(" ARP_REQUEST:\n  PacketIn generata da: switch %s", datapath.id)
        
        destination_host_mac = None
        for host in get_all_host(self):
            if arp_in.dst_ip in host.ipv4:
                destination_host_mac = host.mac
                break
        # self.logger.info(" Host %s --> Host %s (%s)", arp_in.src_ip, arp_in.dst_ip, destination_host_mac)
        # host non trovato
        if destination_host_mac is None:
            # self.logger.info(" Host non trovato")
            # self.logger.info("______________________\n")
            return
        pkt_out = packet.Packet()
        eth_out = ethernet.ethernet(
            dst = eth_in.src,
            src = destination_host_mac,
            ethertype = ether_types.ETH_TYPE_ARP
        )
        arp_out = arp.arp(
            opcode  = arp.ARP_REPLY,
            src_mac = destination_host_mac,
            src_ip  = arp_in.dst_ip,
            dst_mac = arp_in.src_mac,
            dst_ip  = arp_in.src_ip
        )
        pkt_out.add_protocol(eth_out)
        pkt_out.add_protocol(arp_out)
        pkt_out.serialize()
        out = parser.OFPPacketOut(
            datapath=datapath,
            buffer_id=ofproto.OFP_NO_BUFFER,
            in_port=ofproto.OFPP_CONTROLLER,
            actions=[parser.OFPActionOutput(in_port)],
            data=pkt_out.data
        )
        datapath.send_msg(out)
        
        # self.logger.info(" ARP Replied")
        # self.logger.info("______________________\n")
        return
        
    
    @set_ev_cls(ofp_event.EventOFPFlowRemoved, MAIN_DISPATCHER)
    def flow_removed_handler(self, evt):
        
        msg = evt.msg
        datapath = msg.datapath
        ofproto = datapath.ofproto
        dpid = datapath.id
        
        self.logger.info("\n FLOW_REMOVED:\n  Generated by: switch %s", dpid)
        self.logger.info("____________________________________________________________________________________________\n")
        
        if msg.match['ip_proto'] == 6: #TCP
            port_src = 'tcp_src'
            port_dst = 'tcp_dst'
        elif msg.match['ip_proto'] == 17: #UDP
            port_src = 'udp_src'
            port_dst = 'udp_dst'
        
        # Flow Removed: dpid, Interfaccia_d'uscita
        
        #(dpid1, dpid2, Interfaccia_d'uscita_s1, Interfaccia_d'uscita_s2) = (3 ,2 ,5, 4)  ||  (2, 3, 4, 5)
        
        i=0
        while i<len(lista_regole):
            if (dpid == lista_regole[i].dpid1 and msg.table_id == lista_regole[i].table_id1) or (dpid == lista_regole[i].dpid2 and msg.table_id == lista_regole[i].table_id2):
                lista_regole[i].cont+=-1
                self.logger.info("Counter decreased")
                self.logger.info("Residual number of flows on the link [sw %s <-> sw %s]: count = %d", lista_regole[i].dpid1, lista_regole[i].dpid2, lista_regole[i].cont)
                if lista_regole[i].cont == 0:
                    lista_regole.pop(i)
            i+=1
        
        
        self.logger.info("Reason = %s", msg.reason)
        self.logger.info("Removed Rule Match: %s\n", (msg.match['ip_proto'], msg.match['ipv4_src'], msg.match['ipv4_dst'], msg.match[port_src], msg.match[port_dst]))
        self.logger.info("Number link with active flow: %d", len(lista_regole))
        i=0
        while i<len(lista_regole):
            self.logger.info("Active flows: %s --> %s", lista_regole[i].dpid1, lista_regole[i].dpid2)
            i+=1
        self.logger.info("____________________________________________________________________________________________\n")
        
        return
